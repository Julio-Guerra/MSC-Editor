/* PLEASE DO NOT EDIT THIS FILE!!!
   This file contains the MSC2000 C++ grammar and is generated from
   the corresponding MSC2000 Java grammar file.
*/

/*$Id: MSCLexer.g,v 1.27 2002/02/26 14:10:04 neukirchen Exp $

  MSC2000-Lexer Z.120 rev. 1 (11/2001)

  This file is intended to be used with ANTLR 2.7.1 or higher. ANTLR
  is a parser generator that is based on 'linear approximate'
  lookahead analysis (a kind of weak LL(k) analysis). ANTLR is free
  software provided by jGuru.com (MageLang Institute). For further
  information please refer to http://www.antlr.org.

  For the latest release of all MSC2000 grammar files please have a look at
http://www.itm.mu-luebeck.de/research/main_projects/projects/single_projects/index.php?lang=en&pj_nr=8
  We also invite you to visit the WWW pages of the Institute for Telematics
  at http://www.itm.mu-luebeck.de.

  Copyright (C) 2002 Institute for Telematics
  Medical University of Luebeck
  Ratzeburger Allee 160
  23538 Luebeck
  Germany

  Florian Moesch <fmoesch@itm.mu-luebeck.de> 2000
  Ulli Woelfel <woelfel@itm.mu-luebeck.de> 2001
  Helmut Neukirchen <neukirchen@itm.mu-luebeck.de> 2001, 2002

  Many thanks to Michael Schmitt for compiler construction consultancy

  Part of this work is supported by the European Commission
  contract IST-11557 INTERVAL.

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; either version 2 of the
  License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  02111-1307, USA.
*/

/* Annex: C++

   This grammar file uses Java specific code. Nevertheless, it is also used to
   generate C++ code wherefore all rule changes are immediately available for
   both supported languages.

   If code for C++ shall be produced the Java code has to be replaced by the
   corresponding C++ code. Therefore, the following modifications will be done:

   - "set", "get" and "addASTChild" (all starting with a dot) will be replaced by
     "->set", "->get" and "->addASTChild"
     => use NOWHERE these strings in this file

   - header command will be removed and additional option will be inserted
     (see comment "// Java specific => gets replaced if used for C++"

   - own java methods will be replaced by the corresponding C++ functions
     (see comment "// Java specific => gets replaced if used for C++"


   All modifications by header, options before class statement, own methods
   and use of further language dependend ANTLR methods have to be reflected in
   the script which generates the C++ grammar files!
*/



/* For deviation from Z.120 11/99 grammar, search for "/*x" comments.
"/* XXX" comments indicate that there might be problems with that
rule or they need at least some more work. */


// Some info on ANTLR:
// ANTLR code starts here. You might want to view
// it using the ANTLR emacs mode!

// Java specific => gets replaced if used for C++
header "pre_include_hpp" {
    // gets inserted before antlr generated includes in the header file
}
header "post_include_hpp" {
    // gets inserted after antlr generated includes in the header file
    // outside any generated namespace specifications
}

header "pre_include_cpp" {
    // gets inserted after the antlr generated includes in the cpp file

}

header "post_include_cpp" {
    // gets inserted after the antlr generated includes in the cpp file

}

header {
    // gets inserted after generated namespace specifications in the header
    // file. But outside the generated class.

}

options {
	language  = "Cpp";
	namespace = "MSC2000::Parser";// encapsulate code in this namespace
                                    // special ANTLR notation!!!

    namespaceStd = "std";    // cosmetic option to get rid of long defines
    namespaceAntlr = "antlr";// cosmetic option to get rid of long defines
}


class MSCLexer extends Lexer;

options {
	k=3;
	exportVocab = MSCLexer;
	testLiterals = false; // Generate tokens for keywords only if explicitely requested by using "$setType(testLiteralsTable(...))"
	caseSensitive = true;
	}

// Some info on ANTLR:
// These are the tokens which are put into the TokenStream which is
// piped to the Parser (since testLiterals = false, this is only done when
// $setType(testLiteralsTable(...)) is explicitely called):

tokens	{
	ACTION		= "action";
	AFTER		= "after";
	ALL		= "all";
	ALT		= "alt";
	AS		= "as";
	BEFORE		= "before";
	BEGIN		= "begin";
/*x rev 1 removed	BLOCK		= "block"; */
    BOTTOM      = "bottom";  /*x rev 1 */
    BY          = "by"; /*x for MSC96 */
	CALL		= "call";
	COMMENT		= "comment";
	CONCURRENT	= "concurrent";
	CONDITION	= "condition";
	CONNECT		= "connect";
	CREATE		= "create";
	DATA		= "data";
	DECOMPOSED	= "decomposed";
	DEF		= "def";
	EMPTY		= "empty";
	END		= "end";
	ENDCONCURRENT	= "endconcurrent";
	ENDEXPR		= "endexpr";
	ENDINSTANCE	= "endinstance";
	ENDMETHOD	= "endmethod";
	ENDMSC		= "endmsc";
	ENDMSCDOCUMENT = "endmscdocument" ; /*x for MSC92 */
	ENDSUSPENSION	= "endsuspension";
	ENV		= "env";
	EQUALPAR	= "equalpar";
	ESCAPE		= "escape";
	EXC		= "exc";
	EXPR		= "expr";
	EXTERNAL	= "external";
	FINALIZED	= "finalized";
	FOUND		= "found";
	FROM		= "from";
	GATE		= "gate";
	IN		= "in";
	INF		= "inf";
	INHERITS	= "inherits";
	INLINE		= "inline";
	INST		= "inst";
	INSTANCE	= "instance";
	INT_BOUNDARY	= "int_boundary";
	LABEL		= "label";
	LANGUAGE	= "language";
	LOOP		= "loop";
	LOST		= "lost";
	METHOD		= "method";
	MSC		= "msc";
	MSCDOCUMENT	= "mscdocument";
	MSG		= "msg";
	NESTABLE	= "nestable";
	NONNESTABLE	= "nonnestable";
	OFFSET		= "offset";
	OPT		= "opt";
	OTHERWISE	= "otherwise";
	OUT		= "out";
	PAR		= "par";
	PARENTHESIS	= "parenthesis";
/*x rev 1 removed	PROCESS		= "process"; */
	RECEIVE		= "receive";
	REDEFINED	= "redefined";
	REFERENCE	= "reference";
	RELATED		= "related";
	REPLYIN		= "replyin";
	REPLYOUT	= "replyout";
    RESET       = "reset"; /*x for msc96 timers*/
	SEQ		= "seq";
/*x rev 1 removed	SERVICE		= "service"; */
    SET         = "set"; /*x for msc96 timers*/
    SHARED		= "shared";
	STARTTIMER	= "starttimer";
	STOP		= "stop";
	STOPTIMER	= "stoptimer";
    SUBST       = "subst"; /*x for msc96 references */
	SUSPENSION	= "suspension";
/*x rev 1 removed	SYSTEM		= "system"; */
	TEXT		= "text";
	TIME		= "time";
	TIMEOUT		= "timeout";
	TIMER		= "timer";
	TO		= "to";
    TOP         = "top"; /*x rev 1 */
	UNDEF		= "undef";
	USING		= "using";
	UTILITIES	= "utilities";
	VARIABLES	= "variables";
	VIA		= "via";
	VIRTUAL		= "virtual";
	WHEN		= "when";
	WILDCARDS	= "wildcards";

	LeftOpen	= "(" ;
	LeftClosed	= "[" ;
	RightOpen	= ")" ;
	RightClosed	= "]" ;
	AbsTimeMark	= "@" ;
	RelTimeMark	= "&" ;

	Colon		= ":" ;
	Semicolon	= ";" ;
	Comma		= "," ;

	Parent		= "#" ;

	LeftBindSymbol	= ":=" ;
	RightBindSymbol	= "=:" ;

	LeftAngularBracket	= "<" ;
	RightAngularBracket	= ">" ;

/* XXX Helmut: Currently, qualifiers are recognized in this Lexer as a whole (Token "Qualifier"), so "QualifierLeft" and "QualifierRight" need not to be exported anymore */
	QualifierLeft	= "<<" ;
	QualifierRight	= ">>" ;
	}

// Java specific => gets replaced if used for C++
{
 public:
      inline void setCaseSensitiveLiterals( bool t ) {
        caseSensitive = t; };
}


// Some info on ANTLR:
// No "protect" in front of LexicalUnit, hence it is unioned with
// other non "protect", i.e. "Space" to define the lexical units.
// The keywords listed above as tokens are implicitely unioned by ANTLR.
//
// Since we want ANTLR to produce Token 'Name' instead of Letters,
// Digits etc. we set the Tokentype explicitley using $setType


/*x The LexicalUnit definition in Z.120 (11/99) is not usable.
  Hence, word was removed, some terminals from National and OtherCharacter
  were moved to Special. Some of these problems were already spotted
  in ITU-T SG10 temporary document D3 section A.1 and A.3, but not all.
  For details of changes, have a look at these rules. Helmut */

/*x	removed | Word			{ $setType(Word); D3 A.1*/
/*x Helmut: instead: added National */
LexicalUnit
	: Name			    { $setType(testLiteralsTable(Name)); }
	| CharacterString	{ $setType(CharacterString); }
	| Special		    { $setType(testLiteralsTable(Special)); }
//	| CompositeSpecial	{ $setType(CompositeSpecial); } /* XXX Helmut: probably not needed anymore, since Qualifier ist now part of LexicalUnit */
	| Note			    { $setType(Note); }
	| Qualifier		    { $setType(Qualifier); } /*x rev 1, see rule Qualifier */
	| National 		    { $setType(testLiteralsTable(National)); }  /*x added, since due to removement of Word, all those nationals were no Lexical units anymore */
	| Misc			    { $setType(testLiteralsTable(Misc)); }
		/*x At least <Apostrophe> is not as itself part of Z.120 11/99 lexical units */
	/* Keywords - see tokens section */
	;

/*x Rule completely removed D3 A.1*/
/*
   protected Word
   : ( FullStop )?
   Alphanumeric
   ( Alphanumeric | FullStop )*
   ;
*/

protected Alphanumeric
	: Letter
	| DecimalDigit
	| National
	;

protected Letter
	: 'a' .. 'z'
	| 'A' .. 'Z'
	;

protected DecimalDigit
	: '0' .. '9' ;

/*x removed '#' Helmut */
/*x removed '\164', it confuses ANTLR! Helmut */
/*x removed '@' Helmut */
/*x	removed LeftSquareBracket Helmut */
/*x	removed RightSquareBracket Helmut */
protected National
	: '`' | '\\'
	| LeftCurlyBracket
	| VerticalLine
	| RightCurlyBracket
	| Overline
	| UpwardArrowHead
	;

protected LeftSquareBracket
	: '[' ;

protected RightSquareBracket
	: ']' ;

protected LeftCurlyBracket
	: '{' ;

protected VerticalLine
	: '|' ;

protected RightCurlyBracket
	: '}' ;

protected LeftOpen
	: '(' ;

protected LeftClosed
	: LeftSquareBracket ;

protected RightOpen
	: ')' ;

protected RightClosed
	: RightSquareBracket ;

protected AbsTimeMark
	: '@' ;

protected RelTimeMark
	: '&' ;

protected Overline
	: '~' ;

protected UpwardArrowHead
	: '^' ;

protected FullStop
	: '.' ;

protected Underline
	: '_' ;

protected LeftAngularBracket
	: '<' ;

protected RightAngularBracket
	: '>' ;

protected CharacterString
	: Apostrophe! ( Alphanumeric
	| OtherCharacter
	| Special
	| FullStop
	| Underline
	| Space
	| Apostrophe Apostrophe )* Apostrophe!
	;

/*x Since Text is not referenced as a LexicalUnit, Text is not produced
  as a TokenType! */
// Greedy=false is needed, because otherwise the terminating '>>'
// or '*''/' cannot be recognized by Rules Note and Qualifier
protected Text
        : ( options { greedy = false; }
	: Alphanumeric
	| OtherCharacter
	| Special
	| FullStop
	| Underline
	| Space
	| Apostrophe )*
	;

protected Misc /* Florian */
  : OtherCharacter | Apostrophe
  ;

protected Apostrophe
	: '\'' ;

/*x removed '&' | '>' | '<' Helmut + D3 A.3 */
protected OtherCharacter
	: '?' | '%' | '+' | '-' | '!'
	| '/' | '*' | '"' | '='
	;

/*x added '&' | '@' | '>' | '<' Helmut  + D3 A.3 */
/*x added '[' | ']' | '#' Helmut + D3 A.3 */
protected Special
	: LeftOpen | RightOpen | ',' | ';' | ':'
	| RelTimeMark | AbsTimeMark | RightAngularBracket | LeftAngularBracket
	| LeftClosed | RightClosed | '#'
	;

/*x remove, since QualifierLeft & Right are now contained in Qualifier */
//protected CompositeSpecial
//	: QualifierLeft | QualifierRight ;

protected QualifierLeft
	: "<<" ;

protected QualifierRight
	: ">>" ;

protected Note
	: "/*" Text "*/" ;

/* rev 1 moved from Parser to Lexer, because Lexer needs "<<"-context
  information */
protected Qualifier
	: QualifierLeft! Text QualifierRight! ;

protected Name
	: ( Letter | DecimalDigit | Underline | FullStop )+ ;

/* Keyword : see tokens section */

Space	: ( ' ' | '\t' | '\r' | '\n' {newline();} ) ;

/*x Line continuation using '_' not implemented, yet. See Michael
  SchmittsSDL-2000 Parser for a possible solution */
