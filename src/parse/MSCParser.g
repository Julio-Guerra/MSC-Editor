/* PLEASE DO NOT EDIT THIS FILE!!!
   This file contains the MSC2000 C++ grammar and is generated from 
   the corresponding MSC2000 Java grammar file.
*/

/*$Id: MSCParser.g,v 1.58 2002/05/03 13:12:42 neukirchen Exp $

  MSC2000-Parser Z.120 rev. 1 (11/2001)

  This file is intended to be used with ANTLR 2.7.1 or higher. ANTLR
  is a parser generator that is based on 'linear approximate'
  lookahead analysis (a kind of weak LL(k) analysis). ANTLR is free
  software provided by jGuru.com (MageLang Institute). For further
  information please refer to http://www.antlr.org.

  For the latest release of all MSC2000 grammar files please have a look at
  http://www.itm.mu-luebeck.de/research/main_projects/projects/single_projects/index.php?lang=en&pj_nr=8
  We also invite you to visit the WWW pages of the Institute for Telematics
  at http://www.itm.mu-luebeck.de.

  Copyright (C) 2002 Institute for Telematics
  Medical University of Luebeck
  Ratzeburger Allee 160
  23538 Luebeck
  Germany

  Florian Moesch <fmoesch@itm.mu-luebeck.de> 2000
  Ulli Woelfel <woelfel@itm.mu-luebeck.de> 2001
  Helmut Neukirchen <neukirchen@itm.mu-luebeck.de> 2001, 2002
  Michael Ebner <ebner@itm.mu-luebeck.de> 2001, 2002

  Many thanks to Michael Schmitt for compiler construction consultancy

  Part of this work is supported by the European Commission
  contract IST-11557 INTERVAL.

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; either version 2 of the
  License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  02111-1307, USA.
*/


/* Annex: C++

   This grammar file uses Java specific code. Nevertheless, it is also used to
   generate C++ code wherefore all rule changes are immediately available for
   both supported languages.

   If code for C++ shall be produced the Java code has to be replaced by the
   corresponding C++ code. Therefore, the following modifications will be done:

   - "set", "get" and "addASTChild" (all starting with a dot) will be replaced by
     "->set", "->get" and "->addASTChild"
     => use NOWHERE these strings in this file

   - header command will be removed and additional option will be inserted
     (see comment "// Java specific => gets replaced if used for C++"

   - own java methods will be replaced by the corresponding C++ functions
     (see comment "// Java specific => gets replaced if used for C++"

     - the closing bracket, which marks the end of the C++ insertion,
       has to be in the first column to be recognized correctly and all other
       closing brackets inside this C++ insertion have not to be in the first
       column!!!

     - There will be new constructors with an additional parameter to set class
       value msc96. 

       ATTENTION: 
       It has to be made sure that the constructor definitions are up to date!
       Furthermore, without setting variable msc96 by using a corresponding
       constructor or explicitly setting the parser behaviour is NOT defined!

   All modifications by header, options before class statement, own methods
   and use of further language dependend ANTLR methods have to be reflected in
   the script which generates the C++ grammar files!  */



/* Problems and errors encountered in the ITU-T Z.120 rev. 1 (11/2001) recommendation
(not necessarily parser-related):

kindDenominator is simply mapped to an untyped name instead of e.g.kindName.

production mscParmDeclBlock has due to a typo an "h" after its name: remove it!

Syntax interface to external data languages: Production equalParList:
the "equal" in <equal par> needs to be underlined.
Production par and escapechar use characterstring plus delims means is doubled delimiters,
i.e. replace characterstring by something more suitable.

sharedParExpr has still a timeInterval. Shouldn't this be removed, since it
is already contained in sharedInlineExpr?

inlineExpr uses STARTAFTER, ENDAFTER terminals, which should be TOP and BOTTOM
like in sharedInlineExpr.

referenceGateInterface has an end at the beginning, which needs to be moved
at the end!

D3 F suggested to replace a lot of  <end>s by ";". This has not
been implemented in the rev 1 grammar, e.g. at inline expressions.

Example section MSC references: in msc ref, add a ";" after "gate out IDATind, L2 to env"
and also after "gate in IDATreq, L3 from env". In msc data_transmission, add a ":" between  "Medium" and "endinstance".

*/

/* Note: most of the following problems and errors are fixed in ITU-T Z.120 rev. 1 (11/2001) recommendation!

Problems and errors encountered in the ITU-T Z.120 (11/99) recommendation
(not necessarily parser-related):

Problems and errors spotted at the ITU-T November 2000 meeting in
Geneva are assumed as known (ITU-T SG10 11/2000 docs D3, D9, TD58 and
TD59). Nevertheless, not all admitted changes are implemented, yet!


Identified Errors:

p. 72 (Semantics of inline expression): "seq" makes no sense for
inline expressions, only for MSC references.

Wrong Examples: Section 2.10 (HMSC, textual notation): ";" in front of
"seq" keyword has to be removed.

Section 2.4. (Timed MSC, graphical notation): The "MSC" keyword
indicating the document name has to be written in lower case
letters. Moreover, the <msc name> must not be followed by ";".

Section 2.2.1 (Textual example): replace "ring_back_tone on" by
"ring_back_tone_on", "dial_tone off" by "dial_tone_off".


Problems/Need for clarification:

Lexical Units: Z.100 has more(better) text concerning <space>.

Time concept: As an alternative to the dashed lines construct of <int
symbol>, the graphical notation allows to associate a "time" keyword
with a <message symbol>. Is this distinction also reflected in the
textual notation, e.g.\ by ommitting the <time dest>? Furthermore,
when using relative timing, to which event should <time dest> refer,
to the beginning event or the end event of the interval? Is this
arbitrary, or is even a symmetrical referencing needed? (Same applies
probably to "before" and "after" of general ordering...)

p. 65 (production <time point>): It is not decideable whether an "@"
is an optional <abs time mark> or the beginning of a data string.
Suggestion: remove <abs time mark> from <time point> and add it
as a first option to production <singular time>. Remove static requirement
concerning from of absolute time intervals.

p. 66 (production <time interval>): Why is the optional <measurement>
needed? (A measurement can be obtained by expanding <singular time>, a
bounded timed with a measurement can be obtained by expanding <time
dest list> several times...)

p. 16 (data strings, <non-par-non-escape>): What about having "]" in a
<non-par-non-escape>? (")" is forbidden, but "]" isn't...). Moreover the
text "character string containing..." is missleading, because
<character string> is not ment!

p. 16 (data strings, <equal par>): In rule <equal par>, <delim> should
be exchanged with e.g. <open par> and add sentence "The <open par>
must be the corresponding parenthesis delimiters defined in the MSC
document heading defined in 1.7.2."

p. 16 (data strings, <non-nestable par>): Add sentence "<text> must
not contain <close par>, otherwise it must be escaped."

MSC Document part: MSC96 intends several <msc>'s to follow the
<document head>, MSC2000 does not relate MSC document part and <msc>
part to each other.  This was already addressed in ITU-T SG10 11/2000
Document D3, section B.

MSC Document part: An <end> (or ";") for terminating <textual defining part>
and <textual utility part> looks at least nicer. The "utility" keyword is not
optional, but the remainder of that rule.

*/
/*
   The above mentioned problems are not necessarily corrected in this parser!

   For actual deviation from Z.120 11/99 grammar, search for "/*x" comments.
   D3, D9, TD58 and TD59 refer to documents of ITU-T SG10 November 2000 meeting in Geneva,
   TD33 refers to document of ITU-T SG10 September 2001 meeting in Geneva.

   "/* XXX" comments indicate that there might be problems with that
   rule or they need at least some more work.

   Modifications to Z.120 11/99 grammar which are just needed for
   MSC92/96 backward compat. can by found by searching for the semantic
   predicate "{ msc96==true }?".  */

// Some info on ANTLR:
// ANTLR code starts here. You might want to view
// it using the ANTLR emacs mode!

// Java specific => gets replaced if used for C++

header "pre_include_hpp" {
    // gets inserted before antlr generated includes in the header file
}
header "post_include_hpp" {
    // gets inserted after antlr generated includes in the header file
    // outside any generated namespace specifications
#include <string>
using std::string;

}

header "pre_include_cpp" {
    // gets inserted before the antlr generated includes in the cpp file

}

header "post_include_cpp" {
    // gets inserted after the antlr generated includes in the cpp file

}

header {
    // gets inserted after generated namespace specifications in the header
    // file. But outside the generated class.

MSC2000::Parser::MSCParser::MSCParser(antlr::TokenBuffer& tokenBuf, bool _msc96 )
: antlr::LLkParser(tokenBuf,2), msc96 ( _msc96 )
{
	setTokenNames(_tokenNames);
}

MSC2000::Parser::MSCParser::MSCParser(antlr::TokenStream& lexer, bool _msc96 )
: antlr::LLkParser(lexer,2), msc96 ( _msc96 )
{
	setTokenNames(_tokenNames);
}

MSC2000::Parser::MSCParser::MSCParser(const antlr::ParserSharedInputState& state, bool _msc96 )
: antlr::LLkParser(state,2), msc96 ( _msc96 )
{
	setTokenNames(_tokenNames);
}



// Static method returning the revision of the parser grammar
string MSC2000::Parser::MSCParser::getRevision() {
    string rev="$Id: MSCParser.g,v 1.58 2002/05/03 13:12:42 neukirchen Exp $";
    return rev.substr(1,rev.length()-2);
}

// Static method returning the ID of the parser grammar
string MSC2000::Parser::MSCParser::getId() {
    string id = "$Id: MSCParser.g,v 1.58 2002/05/03 13:12:42 neukirchen Exp $";
    return id.substr(1,id.length()-2);
    
}

}

options {
	language  = "Cpp";
	namespace = "MSC2000::Parser";// encapsulate code in this namespace
                                    // special ANTLR notation!!!

    namespaceStd = "std";    // cosmetic option to get rid of long defines
    namespaceAntlr = "antlr";// cosmetic option to get rid of long defines
}


class MSCParser extends Parser;

options {
     k=2;
     importVocab = MSCLexer;
     exportVocab = MSCParser;
     buildAST = true;
}

// Some info on ANTLR:
// These are the nodes which are generated by this Parser to form the
// Abstract Syntax Tree (AST) (lexer tokens may also be part of the AST due to importVocab):

tokens	{ 
     AbsTimeMeasurement ;
     Action ;
     ActionName ;
     ActualInCallGate ;
     ActualInReplyGate ;
     ActualInstanceParameterName ;
     ActualOutCallGate ;
     ActualOutReplyGate ;
     AltExpr ;
     Bottom ;
     BoundedTime ;
     CallIn ;
     CallOut ;
     Comment ;
     Condition ;
     ConditionName ;
     ContainingClause ;
     CreateInGate ;
     CreateOutGate ;
     DataDefinition ;
     DataDefinitionString ;
     DataLanguageName ;	
     Decomposition ;
     DefCreateInGate ;
     DefCreateOutGate ;
     DefiningMscReference ;
     DefInCallGate ;
     DefInGate ;
     DefInReplyGate ;
     DefOrderInGate ;
     DefOrderOutGate ;
     DefOutCallGate ;
     DefOutGate ;
     DefOutReplyGate ;
     DocumentHead ;
     Duration ;
     DurationLimit ;
     DurationName ; /*x for MSC96 backward compat. */
     DynamicDeclarationList ;
     Empty ;
     EndCoregion ;
     EndMethod ;
     EndSuspension ;
     EqualParDelim ;
     EscapeDecl ;
     EventDefinition ;
     EventName;
     Exc ;
     ExcExpr ;
     ExcExpressionEnd ;
     ExpressionString  ;
     GuardingConditionNameList ;
     GuardingConditionExpression ;
     HmscBody ;
     IncompleteCallIn ;
     IncompleteCallOut ;
     IncompleteMessageInput ;
     IncompleteMessageOutput ;
     IncompleteReplyIn ;
     IncompleteReplyOut ;
     InGate ;
     Inheritance ;
     InlineCreateInGate ;
     InlineCreateOutGate ;
     InlineExpr ;
     InlineExprName ;
     InlineGateInterface ;
     InlineInCallGate ;
     InlineInGate ;
     InlineInReplyGate ;
     InlineOrderInGate ;
     InlineOrderOutGate ;
     InlineOutCallGate ;
     InlineOutGate ;
     InlineOutReplyGate ;
     InputAddress ;
     Instance ;
     InstanceCreation ;
     InstanceEnd ;
     InstanceEventList ;
     InstanceEvents ;
     InstanceHead ;
     InstanceKind ;
     InstanceName ;
     InstanceNames ;
     InstanceParameterDeclaration ;
     InstanceParameterName;
     InstanceParameters ;
     InstanceStop ;
     IntervalName ;
     KindName ; /*x added, since rev. 1 doesn't provide a type for kindDenominator, Helmut */
     Label ;
     LabelName ;
     LabelNameList;
     Loop ;
     LoopBoundary ;
     LoopExpr ;
     LoopExpressionEnd ;
     LowerBound ;
     MscExpression ;
	 MscRefParExpr ;
     MscTextualFile ;
     Message ;
     MessageDeclClause ;
     MessageInput ;
     MessageName ;
     MessageOutput ;
     MessageParameters ;
     MessageSequenceChart ;
     MessageSequenceChartName ;
     MessapeParameterDeclaration ;
     MscBody ;
     MscHead ;
     MscName ;
     MscReference ;
     MscRefExpr ;
     MscRefSeqExpr ;
     NestableParPair ;
     Node ;
     NodeExprBody ;
     NodeExpression;
     NonNestableParPair ;
     Opt ;
     OptExpr ;
     OptExpressionEnd ;
     OrderDestList ;
     OrderInGate ;
     OrderOutGate ;
     Otherwise ;
     OutGate ;
     OutputAddress ;
     Parameter ;
     ParameterList ;
     ParenthesisDeclaration ;
     ParExpr ;
     ParExpression ;
     ReferenceName ;
     RelTimeMeasurement ;
     ReplyIn ;
     ReplyOut ;
     SettingConditionNameList ;
     SeqExpr ;
     SharedAltExpr ;
     SharedCondition ;
     SharedExcExpr ;
     SharedInlineExpr ;
     SharedLoopExpr ;
     SharedMscReference ;
     SharedOptExpr ;
     SharedParExpr ;
     SharedSeqExpr ;
     SingularTime ;
     StartCoregion ;
     StartMethod ;
     StartSuspension ;
     StartTimer ;
     StopTimer ;
     TextDefinition ;
     TextualUtilityPart ;
     Time;
     TimeableNode ;
     TimeDest ;
     TimeOffset ;
     TimeOut ;
     TimePoint ;
     TimerDeclClause ;
     TimerName ;
     TimerParameterDeclaration ;
     TimerParameters ;
     Top;
     TypeRefString ;
     UpperBound ;
     UsingClause ;	
     VariableString ;
     WildcardString ;
}

// Some info on ANTLR:
// This is the customised initialisation part:

// Java specific => gets replaced if used for C++
{   // Boolean variable indicating backward compat.
    public: 
        bool msc96;


    // own constructors
	MSCParser(antlr::TokenBuffer& tokenBuf, bool _msc96);
	MSCParser(antlr::TokenStream& lexer, bool _msc96);
	MSCParser(const antlr::ParserSharedInputState& state, bool _msc96);


    // Static method returning the revision of the parser grammar
        static string getRevision();

    // Static method returning the ID of the parser grammar
         static string getId();
}
 // C++ extension: bracket has to be in the first column!!!


// Some info on ANTLR: Syntactic predicates ("... => ..." can be used
// in rules to achieve a deeper lookahead thus removing some
// indeterminisms
//
// Semantic predicate (" { ... }? ...") can be used to en-/disable
// rules at parse time to reflect semantic constraints which came up
// during parse time. We use them mainly to en-/disable the
// recognition of MSC92/96 syntax at run-time.
//
// By default ANTLR generates AST nodes by adding grammar elements in
// linear fashion to the AST. Addition of e.g. a grammar element can
// be disabled by adding "!" to the grammr element, the whole default
// node generation for a rule can be disabled by adding a "!" to the
// rule name. In this case, AST nodes can be generated by hand:
// "##" represents the node which is currently build, "#( ... )"
// creates a new sub-node, "[ ... ]" determines a leaf of type "...".

// Some info on ANTLR:
// MSC2000 BNF starts here:


/*x Helmut ( & D3 B): This rule is not available in MSC2000, */
/*x but quite convenient to gather document head and several MSCs in one file*/

mscTextualFile
	:( { msc96==true }? 	( messageSequenceChart )*
		/*x for non-standard tools which write MSCs without document head*/	
	| {true}? (  textualMSCDocument (messageSequenceChart)* )+
		/*x D3 B */ /* XXX Helmut: isn't it possible to ommit "{true}?" ??? */
	| { msc96==true }?
		textualMSCDocument messageSequenceChart ( ENDMSCDOCUMENT! end )?
		/*x ENDMSCDOCUMENT for MSC92 backward compat. */
    )
		{ ## = #([MscTextualFile], ##); }
	;

/* [Z.120] 1.4.1	-- Lexical Rules
   [Z.120] 1.4.2	-- Visibility and Naming Rules
   [Z.120] 1.4.3	-- Comment */

end	: ( comment )? ";"! ;

comment!
	: COMMENT cs:CharacterString
		{ ## = #[Comment,cs->getText()] ; }
	;

textDefinition!
	: TEXT cs:CharacterString e:end
		{ ## = #( #[TextDefinition,cs->getText()], e ) ; }
	;

/* [Z.120] 1.4.4	-- Drawing Rules
   [Z.120] 1.4.5	-- Paging of MSCs
   [Z.120] 1.5		-- Message Sequence Chart document */

textualMSCDocument
	: { msc96==false }? documentHead textualDefiningPart textualUtilityPart
		/*x plain MSC2000 */
	| { msc96==true }? documentHead textualDefiningPart ( textualUtilityPart )?
		/*x union of MSC2000 and MSC96: in MSC96 there are no textualUtilityPart */
		/*x and textualDefiningPart. Since textualDefiningPart may be empty in   */
		/*x MSC2000, just textualUtilityPart has to be optional.                 */
	;

/*x Several changes, details see below */
documentHead
	:   MSCDOCUMENT! instanceKind ( RELATED! TO! sdlReference )?
		(
			{ msc96==true }? ";"! /*x <end> -> ";", D3 F */
		|   ( inheritance )? ";"! /*x <end> -> ";", D3 F */
			( parenthesisDeclaration )? /*x D3 C */
			dataDefinition  /*x D3 C */
			/*x In MSC2000 this is optional, but dataDefinition can already be empty */
			usingClause
			containingClause
			messageDeclClause
			timerDeclClause
		)
		{ ## = #([DocumentHead], ##); }
	;


textualDefiningPart
	: ( definingMscReference )* ;

textualUtilityPart
	: UTILITIES! ( containingClause )? ( definingMscReference )*
        { ## = #([TextualUtilityPart], ##); }
    ;


definingMscReference
	: REFERENCE! ( virtuality )? mscName
        { ## = #([DefiningMscReference], ##); }
    ;


virtuality
	: VIRTUAL | REDEFINED | FINALIZED ;

/*x <end>->";", D3 F */
usingClause
	: ( USING! instanceKind ";"! )*
        { ## = #([UsingClause], ##); }
    ;


containingClause
	: ( INST! instanceItem )+
		{ ## = #([ContainingClause], ## ); }
	;

/*x <end>->";", D3 F */
instanceItem!
	: in:instanceName ( ":" ik:instanceKind )? ( i:inheritance )?
		( d:decomposition )?
		( ddl:dynamicDeclList | ";"! )
		{ ## = #( in, ik, i, d, ddl ); }
	;

inheritance
	: INHERITS! instanceKind
        { ## = #([Inheritance], ## ); }
    ;

/*x <end>->";", D3 F */
messageDeclClause
	: ( MSG! messageDecl ";"! )*
        { ## = #([MessageDeclClause], ##); }
    ;

/*x <end>->";", D3 F */
timerDeclClause
	: ( TIMER! timerDecl ";"! )*
        { ## = #([TimerDeclClause], ##); }
    ;

sdlReference
	: sdlDocumentIdentifier ;

identifier
	: ( Qualifier )? Name ;

/*x rule qualifier moved to Lexer, because Lexer needs "<<"-context
  information
qualifier
	: QualifierLeft Text QualifierRight ;
*/

/* [Z.120] 1.6		-- Basic MSC
   [Z.120] 1.6.1	-- Message Sequence Chart */

/*x Note: D3 F suggests to replace the <end> by ";" */
messageSequenceChart
	: ( virtuality )? MSC! mscHead ( msc | hmsc ) ENDMSC! end!
		{ ## = #( #[MessageSequenceChart], ## ) ; }
	;

msc	: mscBody ;

mscHead
	: mscName ( mscParameterDecl )? ( timeOffset )? end
		( mscInstInterface )? mscGateInterface
		{ ## = #( #[MscHead], ## ) ; }
	;

/*x rev 1 */
/* XXX Helmut: old rule allowed to have an empty mscParmDeclList, check this */
mscParameterDecl
    : "("! mscParmDeclList ")"!
    ;

/*x rev 1 */
/*x Note: D3 F suggests to replace the <end> by ";" */
mscParmDeclList
    : mscParmDeclBlock ( end mscParmDeclList )?
    ;

/*x rev 1 */
mscParmDeclBlock
    : dataParameterDecl
    | instanceParameterDecl
    | messageParameterDecl
    | timerParameterDecl
    ;

/*x <end> removed, D3 E */
instanceParameterDecl
	: INST! instanceParmDeclList
		{ ## = #( #[InstanceParameterDeclaration], ## ) ; }
	;

instanceParmDeclList
	: instanceParameterName ( ":"! instanceKind )?
		( ","! instanceParmDeclList )?
	;

/*x rev 1 */
instanceParameterName
	: instanceName ;


messageParameterDecl
	: MSG! messageParmDeclList
		{ ## = #( #[MessapeParameterDeclaration], ## ) ; }
	;

messageParmDeclList
	: messageDeclList ;

timerParameterDecl
	: TIMER! timerParmDeclList
		{ ## = #( #[TimerParameterDeclaration], ## ) ; }
	;

timerParmDeclList
	: timerDeclList ;

mscInstInterface
	: containingClause ;

instanceKind!
	: ( ( kindDenominator identifier ) => kd:kindDenominator )? i:identifier
		{ ## = #( #[InstanceKind], i, kd ) ; }
	;

/*x rev 1*/
kindDenominator
	: kindName ;

mscGateInterface
	: ( mscGateDef )* ;

mscGateDef
	: GATE! /*X Helmut: Check AST for this */
		( ( ( gateName )? ( IN | OUT ) ) => mscGate
		| ( ( gateName )? ( CALL | RECEIVE ) ) => methodCallGate
		| replyGate
		| createGate | orderGate ) end
	;

mscGate	: ( ( gateName )? OUT ) => defInGate
	| ( ( gateName )? IN ) => defOutGate
	;

methodCallGate
	: ( ( gateName )? RECEIVE ) => defOutCallGate
	| ( ( gateName )? CALL ) => defInCallGate
	;

replyGate
	: ( ( gateName )? REPLYIN ) => defOutReplyGate
	| ( ( gateName )? REPLYOUT ) => defInReplyGate
	;

createGate
	: defCreateInGate | defCreateOutGate ;

orderGate
	: defOrderInGate | defOrderOutGate ;

mscBody
	: ( mscStatement )*
		{ ## = #( #[MscBody], ## ) ; }
	;

/*x added msc92InstanceHeadStatement for MSC92/96 backward compat. */
mscStatement
	: textDefinition | eventDefinition
    | {msc96==true}? msc92EventDefinition
    ;

/*x added msc92EventDefinition for MSC92/96 backward compat. */
msc92EventDefinition!
    : INSTANCE in:instanceName
        ieh:msc92InstanceHeadStatement iel:instanceEventList
        { ## = #( #[EventDefinition] , #( #[InstanceNames], in),
            #( #[InstanceEvents], ieh, iel) ) ; }
    ;

/*x added msc92InstanceHeadStatement for MSC92/96 backward compat. */
msc92InstanceHeadStatement
    :   ( ( ":"! )? instanceKind )? ( decomposition )? end
        { ## = #( #[InstanceHead], ## ) ; }
    ;

eventDefinition!
 	: ( instanceName ":" instanceEventList ) =>
		in:instanceName ":" iel:instanceEventList
		{ ## = #( #[EventDefinition], #( #[InstanceNames], in ),
            #( #[InstanceEvents], iel ) ) ; }
	| inl:instanceNameList ":" miel:multiInstanceEventList
		{ ## = #( #[EventDefinition],
            #( #[InstanceNames], inl ),
            #( #[InstanceEvents], miel ) ) ; }
	;

/*x syntactic predicate needed due to nondeterminism of Z.120 11/99 rule */
instanceEventList
 	: instanceEvent ( ( instanceEvent ) => instanceEventList )? ;

instanceEvent
	: orderableEvent | nonOrderableEvent ;

/*x <end>->";", D3 F */
orderableEvent!
    :
		( ( {msc96==true}? |  LABEL )
			lbl:( evn: eventName { #lbl = #([Label], evn); } )
			( {msc96==true}? |  end ) )?
		/*x MSC2000 has 'LABEL' and 'end', while MSC96 has not */
        (
			(messageEvent) => r1:messageEvent { ## = #r1;}
		| ime:incompleteMessageEvent {## = #ime; }
		| ( methodCallEvent ) => mce:methodCallEvent {## = #mce; }
		| imce:incompleteMethodCallEvent {## = #imce; }
		| c:create {## = #c; }
		| t:timerStatement {## = #t; }
		| a:action  {## = #a; }
		)
        ( BEFORE bodl:orderDestList { #bodl->setText("before"); })? /*XXX Better add an AST node for this */
        ( AFTER aodl:orderDestList  { #bodl->setText("after"); } )? /*XXX Better add an AST node for this */
        en:end
        time:( TIME! tdl:timeDestList ";"! )? /*XXX Better add an AST node for this */
        {
            astFactory.addASTChild(currentAST, #lbl);
            astFactory.addASTChild(currentAST, #bodl);
            astFactory.addASTChild(currentAST, #aodl);
            astFactory.addASTChild(currentAST, #tdl);
            astFactory.addASTChild(currentAST, #en);
        }
    ;

orderDestList
	: orderDest ( ","! orderDestList )?
		{ ## = #([OrderDestList], ##); }
    ;

/*x rule differs from Z.120 rev 1 for separate AST-Nodes on the same level */
timeDestList
	: timeDestination (","! timeDestList )?

	;

timeDestination
	: ( timeDest )? timeInterval
		{ ## = #([TimeDest], ##); }
		/*x rule differs from Z.120 11/99, (timeDest)? and */
		/*x timeInterval are transposed. D3 */
	;

/*x rev. 1 */
timeDest /*X Helmut: Check AST for this */
	: eventName |  ( TOP { ## = #[Top]; } | BOTTOM { ## = #[Bottom]; } ) (  referenceIdentification | labelName );

/* orderableEvents are terminated in rule orderableEvents by and end or ";", nonOrderableEvents are terminated in later rules */
nonOrderableEvent
	: startMethod | endMethod | startSuspension | endSuspension
	| startCoregion | endCoregion | sharedCondition
	| sharedMSCReference | sharedInlineExpr
	| instanceHeadStatement | instanceEndStatement | stop
	;

instanceNameList
	: instanceName ( ","! instanceName )*
	| ALL { ## = #[Name,"all"] ; }
	;

// original Z.120 11/99 rule:
// multiInstanceEventList
//	: ( multiInstanceEvent )+ ;
/*x syntactic predicate needed due to nondeterminism of Z.120 11/99 rule above*/
multiInstanceEventList
 	: multiInstanceEvent
		( ( multiInstanceEvent ) => multiInstanceEventList )?
	;

multiInstanceEvent
	: condition | mscReference | inlineExpr ;

/* [Z.120] 1.6.2	-- Instance */

instanceHeadStatement
	: INSTANCE! ( instanceKind )? ( decomposition )? end
		{ ## = #( #[InstanceHead], ## ) ; }
	;

instanceEndStatement
	: ENDINSTANCE! end
		{ ## = #( #[InstanceEnd], ## ) ; }
	;

/* [Z.120] 1.6.3	-- Message */

messageEvent
	: messageOutput | messageInput ;

messageOutput
	: OUT! msgIdentification TO! inputAddress
		{ ## = #( #[MessageOutput], ## ) ; }
	;

messageInput
	: IN! msgIdentification FROM! outputAddress
		{ ## = #( [MessageInput], ## ) ; }
	;

incompleteMessageEvent
	: incompleteMessageOutput | incompleteMessageInput ;

incompleteMessageOutput
	: OUT! msgIdentification TO! LOST! ( inputAddress )?
		{ ## = #( [IncompleteMessageOutput], ## ) ; }
	;

incompleteMessageInput
	: IN! msgIdentification FROM! FOUND! ( outputAddress )?
		{ ## = #( [IncompleteMessageInput], ## ) ; }
	;

msgIdentification
	: messageName ( ","! messageInstanceName )?
		( "("! parameterList ")"! )?
		{ ## = #( #[Message], ## ) ; }
	;

outputAddress
	: ( instanceName
		| ( ENV | referenceIdentification ) ( VIA gateName )? )
		{ ## = #( #[OutputAddress], ## ) ; }
	;

referenceIdentification
	: REFERENCE! mscReferenceIdentification /*x Helmut: Check AST for this */
	| INLINE! inlineExprIdentification
	;

inputAddress
	: ( instanceName
		| ( ENV | referenceIdentification ) ( VIA gateName )? )
		{ ## = #( #[InputAddress], ## ) ; }
	;

/* [Z.120] 1.6.4	-- Control Flow */

methodCallEvent
	: callOut | callIn | replyOut | replyIn ;

callOut
	: CALL! msgIdentification TO! inputAddress
		{ ## = #( #[CallOut], ## ) ; }
	;

callIn
	: RECEIVE! msgIdentification FROM! outputAddress
		{ ## = #( #[CallIn], ## ) ; }
	;

replyOut
	: REPLYOUT! msgIdentification TO! inputAddress
		{ ## = #( #[ReplyOut], ## ) ; }
	;

replyIn
	: REPLYIN! msgIdentification FROM! outputAddress
		{ ## = #( #[ReplyIn], ## ) ; }
	;

incompleteMethodCallEvent
	: incompleteCallOut | incompleteCallIn |
		incompleteReplyOut | incompleteReplyIn
	;

incompleteCallOut
	: CALL! msgIdentification TO! LOST! ( inputAddress )?
		{ ## = #( #[IncompleteCallOut], ## ) ; }
	;

incompleteCallIn
	: RECEIVE! msgIdentification FROM! FOUND! ( outputAddress )?
		{ ## = #( #[IncompleteCallIn], ## ) ; }
	;

incompleteReplyOut
	: REPLYOUT! msgIdentification TO! LOST! ( inputAddress )?
		{ ## = #( #[IncompleteReplyOut], ## ) ; }
	;

incompleteReplyIn
	: REPLYIN! msgIdentification FROM! FOUND! ( outputAddress )?
		{ ## = #( #[IncompleteReplyIn], ## ) ; }
	;

startMethod
	: METHOD! end
		{ ## = #( #[StartMethod], ## ) ; }
	;

endMethod
	: ENDMETHOD! end
		{ ## = #( #[EndMethod], ## ) ; }
	;

startSuspension
	: SUSPENSION! end
		{ ## = #( #[StartSuspension], ## ) ; }
	;

endSuspension
	: ENDSUSPENSION! end
		{ ## = #( #[EndSuspension], ## ) ; }
	;

/* [Z.120] 1.6.5	-- Environment and Gates */

actualOutGate
	: ( gateName )? OUT! msgIdentification TO! inputDest
		{ ## = #( #[OutGate], ## ) ; }
	;

actualInGate
	: ( gateName )? IN! msgIdentification FROM! outputDest
		{ ## = #( #[InGate], ## ) ; }
	;

inputDest
	: LOST! ( ( inputAddress ) => inputAddress )? | inputAddress ;

outputDest
	: FOUND! ( ( outputAddress ) => outputAddress )? | outputAddress ;

defInGate
	: ( gateName )? OUT! msgIdentification TO! inputDest
		{ ## = #( #[DefInGate], ## ) ; }
	;

defOutGate
	: ( gateName )? IN! msgIdentification FROM! outputDest
		{ ## = #( #[DefOutGate], ## ) ; }
	;

actualOrderOutGate
	: gateName BEFORE! orderDest
		{ ## = #( #[OrderOutGate], ## ) ; }
	;

orderDest
	: eventName | ( ENV | referenceIdentification ) VIA gateName ;

actualOrderInGate
	: gateName
		( AFTER! orderDest )?
		{ ## = #( #[OrderInGate], ## ) ; }
	;

defOrderInGate
	: gateName BEFORE! orderDest
		{ ## = #( #[DefOrderInGate], ## ) ; }
	;

defOrderOutGate
	: gateName
		( AFTER! orderDestList )?
		{ ## = #( #[DefOrderOutGate], ## ) ; }
	;

actualCreateOutGate
	: CREATE! OUT! createGateIdentification CREATE! createTarget
		{ ## = #( #[CreateOutGate], ## ) ; }
	;

actualCreateInGate
	: CREATE! IN! createGateIdentification
		{ ## = #( #[CreateInGate], ## ) ; }
	;

createTarget
	: instanceName | ( ENV | referenceIdentification ) ( VIA gateName )? ;

defCreateInGate
	: CREATE! OUT! ( createGateIdentification )?
		CREATE! createTarget
        { ## = #( #[DefCreateInGate], ## ) ; }
	;

defCreateOutGate
	: CREATE! IN! createGateIdentification
        { ## = #( #[DefCreateOutGate], ## ) ; }
	;

inlineOutGate
	: defOutGate
		( EXTERNAL! OUT! msgIdentification TO! inputDest )?
        { ## = #( #[InlineOutGate], ## ) ; }
	;

inlineInGate
	: defInGate
		( EXTERNAL! IN! msgIdentification FROM! outputDest )?
        { ## = #( #[InlineInGate], ## ) ; }
	;

inlineOutCallGate
	: defOutCallGate
		( EXTERNAL! CALL! msgIdentification TO! inputDest )?
        { ## = #( #[InlineOutCallGate], ## ) ; }
	;

inlineInCallGate
	: defInCallGate
		( EXTERNAL! RECEIVE! msgIdentification FROM! outputDest )?
        { ## = #( #[InlineInCallGate], ## ) ; }
	;

inlineOutReplyGate
	: defOutReplyGate
		( EXTERNAL! REPLYOUT! msgIdentification TO! inputDest )?
        { ## = #( #[InlineOutReplyGate], ## ) ; }
	;

inlineInReplyGate
	: defInReplyGate
		( EXTERNAL! REPLYIN! msgIdentification FROM! outputDest )?
        { ## = #( #[InlineInReplyGate], ## ) ; }
	;

inlineCreateOutGate
	: defCreateOutGate 
        ( EXTERNAL! create )? 
        { ## = #( #[InlineCreateOutGate], ## ) ; }
	;

inlineCreateInGate
	: defCreateInGate
	    ( EXTERNAL! CREATE! FROM! createSource )?
        { ## = #( #[InlineCreateInGate], ## ) ; }
	;

createSource
	: instanceName
	| ( ENV | referenceIdentification ) ( VIA createGateIdentification )?
    ;

inlineOrderOutGate
	: gateName
		( ( AFTER! orderDestList )? EXTERNAL! BEFORE! orderDest )?
        { ## = #( #[InlineOrderOutGate], ## ) ; }
	;

inlineOrderInGate
	: gateName BEFORE! orderDest
		( EXTERNAL! ( AFTER! orderDestList )? )?
        { ## = #( #[InlineOrderInGate], ## ) ; }
	;

actualOutCallGate
	: ( gateName )? CALL! msgIdentification TO! inputDest
        { ## = #( #[ActualOutCallGate], ## ) ; }
;

actualInCallGate
	: ( gateName )? RECEIVE! msgIdentification FROM! outputDest
        { ## = #( #[ActualInCallGate], ## ) ; }
;

defInCallGate
	: ( gateName )? CALL! msgIdentification TO! inputDest
          { ## = #([DefInCallGate], ## ); }
     ;

defOutCallGate
     : ( gateName )? RECEIVE! msgIdentification FROM! outputDest
          { ## = #([DefOutCallGate], ## ); }
     ;

actualOutReplyGate
	: ( gateName )? REPLYOUT! msgIdentification TO! inputDest
          { ## = #([ActualOutReplyGate], ## ); }
;

actualInReplyGate
	: ( gateName )? REPLYIN! msgIdentification FROM! outputDest
          { ## = #([ActualInReplyGate], ## ); }
    ;

defInReplyGate
	: ( gateName )? REPLYOUT! msgIdentification TO! inputDest
          { ## = #([DefInReplyGate], ## ); }
;

defOutReplyGate
	: ( gateName )? REPLYIN! msgIdentification FROM! outputDest
          { ## = #([DefOutReplyGate], ## ); }
;

/* [Z.120] 1.6.6	-- General ordering
			   defined in 1.6.1
   [Z.120] 1.6.7	-- Condition */

sharedCondition!
	: ( s1:shared )? ci:conditionIdentification s2:shared e:end
		{ ## = #( #[SharedCondition], ci, s1, s2, e ) ; }
	;

conditionIdentification
	: CONDITION! conditionText ;

conditionText! 
	: ( c1:conditionNameList { ## = #( #[SettingConditionNameList], c1 ) ; }
      | WHEN 
            ( c2:conditionNameList { ## = #( #[GuardingConditionNameList], c2 ) ; }
            | "(" e1:expression ")" { ## = #( #[GuardingConditionExpression], e1 ) ; }
            )
      | OTHERWISE { ## = #( #[GuardingConditionNameList], #[Otherwise] ) ; }
	  )
	;

conditionNameList
	: conditionName
		( ","! conditionName )*
	;

/* XXX Helmut: Check AST for this  */
shared	
	: SHARED! ( ( sharedInstanceList )? | ALL )
	;

sharedInstanceList
	: instanceName ( ","! sharedInstanceList )? ;

condition!
	: ( s:shared )? ci:conditionIdentification e:end
		{ ## = #( #[Condition], ci, s, e ) ; }
	;

/* [Z.120] 1.6.8	-- Timer */

/*x for MSC96 backward compat., we need also SET and RESET*/
timerStatement
	: { msc96==true }? ( set | reset )
	| starttimer | stoptimer
	| timeout
	;

/*x only in MSC96*/
set
	: { msc96==true }?
	SET! timerName ( ","! timerInstanceName )? ("("! durationName ")"! )?
		{ ## = #( #[StartTimer], ## ) ; }
	;

/*x only in MSC96*/
reset
	: { msc96==true }?
	RESET! timerName ( ","! timerInstanceName )?
		{ ## = #( #[StopTimer], ## ) ; }
	;

starttimer
	: (STARTTIMER!) timerName ( ","! timerInstanceName )? (duration)?
		( "("! parameterList ")"! )?
		{ ## = #( #[StartTimer], ## ) ; }
	;

duration
	: LeftClosed!
	( minDurationlimit )? ( ","! maxDurationlimit )?
	RightClosed!
		{ ## = #( #[Duration], ## ) ; }
	;

durationlimit
	: ( expressionString | INF )
		{ ##->setType(DurationLimit) ; }
	;

stoptimer
	: STOPTIMER!  timerName ( ","! timerInstanceName )?
		{ ## = #( #[StopTimer], ## ) ; }
	;

timeout
 	: TIMEOUT! timerName ( ","! timerInstanceName )?
		( "("! parameterList ")"! )?
		{ ## = #( #[TimeOut], ## ) ; }
	;

/* [Z.120] 1.6.9	-- Action */

action	: ACTION! actionStatement
		{ ## = #( #[Action], ## ) ; }
	;

actionStatement
	: ( informalAction | dataStatementList )
		{ ##->setType(ActionName); }
	;

informalAction
	: CharacterString ;

/* [Z.120] 1.6.10	-- Instance creation */

create	
    : CREATE! instanceName ( "("! parameterList ")"! )?
		{ ## = #( #[InstanceCreation], ## ) ; }
	;

/* [Z.120] 1.6.11	-- Instance stop */

stop	
    : STOP! end
		{ ## = #( #[InstanceStop], ## ) ; }
	;

/* [Z.120] 1.7		-- Data Concepts
   [Z.120] 1.7.1	-- Introduction
   [Z.120] 1.7.2	-- Syntax interface to external data languages */


/*x rev 1 */
/*x Note: D3 F suggests to replace the <end> by ";" */

parenthesisDeclaration
	: PARENTHESIS! parDeclList end
        { ## = #( #[ParenthesisDeclaration], ## ) ; }
    ;

/*x rev 1 */
parDeclList
	: ( nestableParPair | nonNestableParPair | equalParDecl
		| escapeDecl )
		( parDeclList )?
	;

/*x rev 1 */
nestableParPair
	: NESTABLE! pairParList end
        { ## = #( #[NestableParPair], ## ) ; }
    ;

/*x rev 1 */
nonNestableParPair
	: NONNESTABLE! pairParList end
        { ## = #( #[NonNestableParPair], ## ) ; }
    ;

/*x rev 1 */
equalParDecl
	: EQUALPAR! equalParList end
        { ## = #( #[EqualParDelim], ## ) ; }
    ;

escapeDecl
	: ESCAPE! escapechar
        { ## = #( #[EscapeDecl], ## ) ; }
    ;

/*x rev 1 */
pairParList
    : pairPar ( ","! pairParList )? ;

/*x rev 1 */
/* XXX Helmut: One big problem is that currently the Lexer doesn't
  produce the right tokens for the Delims and also the Pars!  */
pairPar
    : delim openPar delim closePar delim ;

/* XXX Helmut: One big problem is that currently the Lexer doesn't
  produce the right tokens for the Delims and also the Pars!  */
/*x rev 1 */
equalParList
    : equalPar ( ","! equalParList )? ;

/* XXX Helmut: MSCLexer.g does $setType(Name) for e.g. Fullstop, so it */
/*x is currently not possible to match for e.g. a Fullstop */
/*x Instead we would have to match for Name! */

delim
// Z.120 (11/99):
//    : Apostrophe
//    | Alphanumeric
//    | OtherCharacter
//    | Special
//    | FullStop
//    | Underline
//    ;
    : Alphanumeric
    | Misc // = Apostrophe | OtherCharacter
 	| Special
	| FullStop /* Helmut: Fullstop is not generated by the Lexer! */
    | Underline/* Helmut: Underline is not generated by the Lexer! */
 	;


/* XXX Florians version:
delim
    : Apostrophe
 	  OtherCharacter
 	  | Special
	  | { ( LT(1)->getText().length() == 1 ) }? ( Alphanumeric	| FullStop | Underline )
 	;
*/

openPar
    : par ;

closePar
    : par ;

equalPar
    : par ;

/*x CharacterString as in Z.120 11/99 & rev 1 is wrong,  because we have already */
/*x the delims as apostrophe, so Text would be a solution. */
/*x But Text doesn't work either, because it is not a LexicalUnit and */
/*x thus no TokenType which can be matched in this Parser! */
/*x Thus we use currently Name | National | Special | Misc ... */
par
	: Name | National | Special | Misc ;


/*x CharacterString as in Z.120 11/99 & rev 1 is wrong,  because we have already */
/*x the delims as apostrophe, so Text would be a solution. */
/*x But Text doesn't work either, because it is not a LexicalUnit and */
/*x thus no TokenType which can be matched in this Parser! */
/*x Thus we use currently Name | National | Special | Misc ... */
escapechar
	: delim (Name | National | Special | Misc ) delim;

/* [Z.120] 1.7.3	-- Semantic interface to external data languages
   [Z.120] 1.7.4	-- Declaring data */

/*x Note: D3 F suggests to replace the <end> by ";" */
messageDeclList
	: messageDecl end ( messageDeclList )?  ;

messageDecl!
	: mnl:messageNameList ( ":"! "("! trl:typeRefList ")"! )?
		{ ## = #( mnl, trl ) ; }
	;

messageNameList
	: messageName ( ","! messageNameList )? ;

/*x Note: D3 F suggests to replace the <end> by ";" */
timerDeclList
	: timerDecl end ( timerDeclList )? ;

timerDecl!
	: tnl:timerNameList ( d:duration )? ( ":"! "("! trl:typeRefList ")"! )?
		{ ## = #( tnl, d, trl ) ; }
	;

timerNameList
	: timerName ( ","! timerNameList )? ;

typeRefList
	: typeRefString ( ","! typeRefList )? ;


/*x rev 1 */
/*x Note: D3 F suggests to replace the <end> by ";" */
dynamicDeclList
	: VARIABLES! variableDeclList end
		{ ## = #( #[DynamicDeclarationList], ## ) ; }
	;

/*x Note: D3 F suggests to replace the <end> by ";" */
/* XXX Helmut: since dynamicDeclList uses already ";" as seperator, a ","
might be nicer? Check this! */
variableDeclList
	: variableDeclItem  ( ( end variableDeclItem ) => end variableDeclList )? ;

variableDeclItem
	: variableList ":"! typeRefString ;

variableList
	: variableString ( ","! variableList )? ;

/*x Note: D3 F suggests to replace the <end> by ";" */
dataDefinition
	: ( LANGUAGE! dataLanguageName end )?
		( wildcardDecl )?
		( DATA! dataDefinitionString end )?
		{ ## = #( #[DataDefinition], ## ) ; }
	;

wildcardDecl
	: WILDCARDS! variableDeclList ; // Helmut: Check AST for this!

/* [Z.120] 1.7.5	-- Static Data */

/*x rev 1 */
dataParameterDecl
	: ( VARIABLES! )? variableDeclList ; // Helmut: Check AST for this!

/*x rev 1 */
actualDataParameters
	: ( VARIABLES! )? actualDataParameterList ; // Helmut: Check AST for this!

actualDataParameterList
	: expressionString ( ","! actualDataParameterList )? ;

/* [Z.120] 1.7.6	-- Dynamic Data
   [Z.120] 1.7.7	-- Bindings */

binding
	: leftBinding | rightBinding ;

leftBinding
	: pattern leftBindSymbol expression ;

leftBindSymbol
	: ":=" ;

rightBinding
	: expression rightBindSymbol pattern ;

rightBindSymbol
	: "=:" ;

expression
	: expressionString ;

pattern
	: ( variableString ) => variableString
	| wildcard
	;

wildcard
	: wildcardString ;

/* [Z.120] 1.7.8	-- Data in message and timer parameters */

parameterList
	: parameterDefn ( ","! parameterList )?
		{ ## = #( #[ParameterList], ## ) ;}
	;
/*x Helmut: ? or * ? check this! */
/*x Ulli: definitely '?' !       */
/*x	: parameterDefn ( ","! parameterDefn )*  */


parameterDefn
	: ( binding
		| ( expression ) => expression
		| pattern
		)
/*		{ ##->setType(Parameter); }*/
	;

/* [Z.120] 1.7.9	-- Data in instance creation parameters
   [Z.120] 1.7.10	-- Data in action boxes */

dataStatementList
	: dataStatement ( ","! dataStatementList )? ;

dataStatement
	: defineStatement | undefineStatement | binding ;

defineStatement
	: DEF variableIdentifier ;

undefineStatement
	: UNDEF variableIdentifier ;

/* [Z.120] 1.7.11	-- Assumed Data Types
   [Z.120] 1.8		-- Time Concepts
   [Z.120] 1.8.1	-- Timed Semantics
   [Z.120] 1.8.2	-- Relative Timing
   [Z.120] 1.8.3	-- Absolute Timing
   [Z.120] 1.8.4	-- Time Domain
   [Z.120] 1.8.5	-- Static and Dynamic Time Variables
   [Z.120] 1.8.6	-- Time Offset */

timeOffset
	: OFFSET! timeExpression
		{ ## = #( #[TimeOffset], ## ) ; }
	;

/* [Z.120] 1.8.7	-- Time Points, Measurements, and Intervals
   [Z.120] 1.8.8	-- Time Points */

/*X Helmut: Check AST for this (what is constructed for AbsTimeMark?) */
timePoint
	: ( AbsTimeMark )?
        timeExpression
		{ ## = #( #[TimePoint], ## ) ; }
	;

/* [Z.120] 1.8.9	-- Measurements */

measurement
	: relMeasurement
	| absMeasurement
	;

relMeasurement
	: RelTimeMark! timePattern
		{ ## = #( #[RelTimeMeasurement], ## ) ; }
	;

absMeasurement
	: AbsTimeMark! timePattern
		{ ## = #( #[AbsTimeMeasurement], ## ) ; }
	;

/* [Z.120] 1.8.10	-- Time Interval */

timeInterval
	: ( ( intervalLabel )? singularTime ) => ( intervalLabel )? singularTime
	| ( ( intervalLabel )? boundedTime  ) => ( intervalLabel )? boundedTime
		(measurement)?
	;

intervalLabel
	: INT_BOUNDARY! intervalName ;

singularTime
	: LeftClosed! timePoint RightClosed! { ## = #(#[SingularTime], ##); }
	| measurement
	;

/*X Helmut: Check AST for this (what is constructed for AbsTimeMark?) */
boundedTime!
	: ( atm:AbsTimeMark  )?
        l:( lo:LeftOpen { #l = #lo ; } 
          | lc:LeftClosed { #l = #lc ; } )
        lb:( tp1:timePoint  { #lb = #([LowerBound], tp1 ); } )?  
        ","!
        ub:( tp2:timePoint  { #ub = #([UpperBound], tp2 ); } )?
        r:( ro:RightOpen { #r = #ro ; }
          | rc:RightClosed { #r = #rc ; } )
		{ ## = #(#[BoundedTime], atm, l, lb, ub, r ); }
	;

/* [Z.120] 1.9		-- Structural Concepts
   [Z.120] 1.9.1	-- Coregion */

startCoregion
	: CONCURRENT! end
		{ ## = #( #[StartCoregion], ## ) ; }
	;

endCoregion
	: ENDCONCURRENT! end
		{ ## = #( #[EndCoregion], ## ) ; }
	;

/* [Z.120] 1.9.2	-- Inline expression */


/*x rev 1 */
/*x Note: D3 F suggests to replace most of the <end> by ";" */
sharedInlineExpr 
	: ( extraGlobal )? ( sharedLoopExpr | sharedOptExpr
		| sharedAltExpr | sharedSeqExpr | sharedParExpr | sharedExcExpr)

		time:(! TIME ti:timeInterval e1:end {#time = #([Time], ti, e1); } )?
		top:(! TOP ttdl:timeDestList e2:end {#top = #([Top], ttdl, e2); } )?
		bottom:(! BOTTOM btdl:timeDestList e3:end {#bottom = #([Bottom], btdl, e3); } )?
        { ## = #( #[SharedInlineExpr], ##, time, top, bottom ); }
	;

extraGlobal
	: EXTERNAL ;

/*x rev 1 */
/*x Note: D3 F suggests to replace second <end>->";"*/
sharedLoopExpr
	: LOOP! ( loopBoundary )? BEGIN! ( inlineExprIdentification )? shared end
		( inlineGateInterface )? (! iel:instanceEventList { astFactory.addASTChild(currentAST, #( [InstanceEventList], iel) ); } )?
		LOOP! END! end
          { ## = #( #[SharedLoopExpr], ## ); }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace second <end>->";"*/
sharedOptExpr
	: OPT! BEGIN! ( inlineExprIdentification )? shared end
		( inlineGateInterface )? (! iel:instanceEventList { astFactory.addASTChild(currentAST, #( [InstanceEventList], iel) ); } )?
		OPT! END! end
          { ## = #( #[SharedOptExpr], ## ); }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace second <end>->";"*/
sharedExcExpr
	: EXC! BEGIN! ( inlineExprIdentification )? shared end
		( inlineGateInterface )? (! iel:instanceEventList { astFactory.addASTChild(currentAST, #( [InstanceEventList], iel) ); } )?
		EXC! END! end
          { ## = #( #[SharedExcExpr], ## ); }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace second <end>->";"*/
sharedAltExpr
	: ALT! BEGIN! ( inlineExprIdentification )? shared end
		( inlineGateInterface )? 
        (! ( instanceEventList ) => iel:instanceEventList { astFactory.addASTChild(currentAST, #( [InstanceEventList], iel) ); } )?
		( ALT! end ( inlineGateInterface )?
			(! ( instanceEventList ) => iel2:instanceEventList { astFactory.addASTChild(currentAST, #( [InstanceEventList], iel2) ); } )? )*
		ALT! END! end
          { ## = #( #[SharedAltExpr], ## ); }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace second <end>->";"*/
sharedSeqExpr
	: SEQ! BEGIN! ( inlineExprIdentification )? shared end
		( inlineGateInterface )? 
        (! ( instanceEventList ) => iel:instanceEventList { astFactory.addASTChild(currentAST, #( [InstanceEventList], iel) ); } )?
		( SEQ! end ( inlineGateInterface )?
			(! ( instanceEventList ) => iel2:instanceEventList { astFactory.addASTChild(currentAST, #( [InstanceEventList], iel2) ); } )? )*
		SEQ! END! end
          { ## = #( #[SharedSeqExpr], ## ); }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace second <end>->";"*/
/*x (timeInterval)? suggested in rev 1 removed */
sharedParExpr
	: PAR! BEGIN! ( inlineExprIdentification )? shared end
		( inlineGateInterface )? 
        (! ( instanceEventList ) => iel:instanceEventList { astFactory.addASTChild(currentAST, #( [InstanceEventList], iel) ); } )?
        ( PAR! end ( inlineGateInterface )?
			(! ( instanceEventList ) => iel2:instanceEventList  { astFactory.addASTChild(currentAST, #( [InstanceEventList], iel2) ); })? )*
        PAR! END! end    
        { ## = #( #[SharedParExpr], ## ); }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace most of the <end>s by ";"*/
inlineExpr
	: ( extraGlobal )?  ( loopExpr | optExpr | altExpr
		| seqExpr | parExpr | excExpr )
		time:(! TIME ti:timeInterval e1:end {#time = #([Time], ti, e1); } )?
		top:(! TOP ttdl:timeDestList e2:end {#top = #([Top], ttdl, e2); } )?
		bottom:(! BOTTOM btdl:timeDestList e3:end {#bottom = #([Bottom], btdl, e3); } )?
          { ## = #( #[InlineExpr], ##, time, top, bottom ); }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace most of the <end>s by ";"*/
loopExpr
	: LOOP! ( loopBoundary )? BEGIN!
		( inlineExprIdentification )? end
		( inlineGateInterface )? mscBody
		LOOP! END! end
		{ ## = #( #[LoopExpr], ## ); }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace most of the <end>s by ";"*/
optExpr
	: OPT! BEGIN! ( inlineExprIdentification )? end
		( inlineGateInterface )? mscBody
		OPT! END! end
		{ ## = #( #[OptExpr], ## ) ; }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace most of the <end>s by ";"*/
excExpr
	: EXC! BEGIN! ( inlineExprIdentification )? end
		( inlineGateInterface )? mscBody
		EXC! END! end
		{ ## = #( #[ExcExpr], ## ) ; }
	;


/*x rev 1 */
/*x Note: D3 F suggests to replace most of the <end>s by ";"*/
altExpr
	: ALT! BEGIN! ( inlineExprIdentification )? end
		( inlineGateInterface )? mscBody
		( ALT! end ( inlineGateInterface )? mscBody )*
		ALT! END! end
		{ ## = #( #[AltExpr], ## ) ; }
	;

/*x rev 1 */
seqExpr
	: SEQ! BEGIN! ( inlineExprIdentification )? end
		( inlineGateInterface )? mscBody
		( SEQ! end ( inlineGateInterface )? mscBody )*
		SEQ! END! end
		{ ## = #( #[SeqExpr], ## ) ; }
	;

parExpr
	: PAR! BEGIN! ( inlineExprIdentification )? end
		( inlineGateInterface )? mscBody
		( PAR! end ( inlineGateInterface )? mscBody )*
		PAR! END! ";"!
        { ## = #( #[ParExpr], ## ) ; }
	;

loopBoundary
	: LeftAngularBracket!
		infNatural ( ","! infNatural )?
		RightAngularBracket!
		{ ## = #( #[LoopBoundary], ## ) ; }
	;

infNatural
	: INF | expression ;

inlineExprIdentification
	: inlineExprName ;

inlineGateInterface
	: ( GATE! inlineGate end )+
		{ ## = #( #[InlineGateInterface], ## ) ; }
	;

inlineGate
	: ( ( gateName )? IN ) => inlineOutGate
	| ( ( gateName )? OUT ) => inlineInGate
	| ( ( gateName )? CREATE IN ) => inlineCreateOutGate
	| inlineCreateInGate
	| ( ( gateName )? RECEIVE ) => inlineOutCallGate
	| ( ( gateName )? CALL ) => inlineInCallGate
	| ( ( gateName )? REPLYIN ) => inlineOutReplyGate
	| inlineInReplyGate
	| inlineOrderOutGate
	| inlineOrderInGate
	;

/* [Z.120] 1.9.3	-- MSC reference */

/*x rev 1 */
/*x Note: D3 F suggests to replace most of the <end>s by ";"*/
sharedMSCReference
	: REFERENCE! ( mscReferenceIdentification ":"! )?
		mscRefExpr shared end
		time:(! TIME ti:timeInterval e1:end {#time = #([Time], ti, e1); } )?
		top:(! TOP ttdl:timeDestList e2:end {#top = #([Top], ttdl, e2); } )?
		bottom:(! BOTTOM btdl:timeDestList e3:end {#bottom = #([Bottom], btdl, e3); } )?
		referenceGateInterface
		{ ## = #( #[SharedMscReference], ##, time, top, bottom ) ; }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace most of the <end>s by ";"*/
mscReference
	: REFERENCE! ( mscReferenceIdentification ":"! )?
        mscRefExpr end
		time:(! TIME ti:timeInterval e1:end {#time = #([Time], ti, e1); } )?
		top:(! TOP ttdl:timeDestList e2:end {#top = #([Top], ttdl, e2); } )?
		bottom:(! BOTTOM btdl:timeDestList e3:end {#bottom = #([Bottom], btdl, e3); } )?
		referenceGateInterface
		{ ## = #( #[MscReference], ##, time, top, bottom ) ; }
	;

mscReferenceIdentification
	: mscReferenceName ;

mscRefExpr
     : mscRefParExpr ( ALT! mscRefParExpr )*
          { ## = #( #[MscRefExpr], ## ) ; }
     ;

mscRefParExpr
     : mscRefSeqExpr ( PAR! mscRefSeqExpr )*
          { ## = #( #[MscRefParExpr], ## ) ; }
     ;

mscRefSeqExpr
     : mscRefIdentExpr ( SEQ! mscRefIdentExpr )*
          { ## = #( #[MscRefSeqExpr], ## ) ; }
     ;

mscRefIdentExpr
    : LOOP! ( loopBoundary )? mscRefIdentExpr { ## = #(#[Loop], ##);}
    | EXC! mscRefIdentExpr { ## = #(#[Exc], ##);}
    | OPT! mscRefIdentExpr { ## = #(#[Opt], ##);}
    | EMPTY! { ## = #(#[Empty], ##);}
    | ( parent )* mscName ( ( { msc96==true }? parameterSubstitution ) | actualParameters )?
    | "("! mscRefExpr ")"!
    ;

/*x only used in msc96 */
parameterSubstitution
    : SUBST substitutionList
    ;

/*x only used in msc96 */
substitutionList
    : substitution (","! substitutionList)?
    ;

/*x only used in msc96 */
substitution
    : replaceMessageInstanceMsc
    ;

/*x only used in msc96 */
replaceMessageInstanceMsc
    : ( MSG | INST | MSC )? Name BY Name /*x MSC96 distinguished beetwen msgName, instName, mscName */
    ;

/*x rev 1 */
actualParameters
	: "("!  actualParametersList ")"!
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace the <end> by ";"*/
actualParametersList
    : actualParametersBlock ( end actualParametersList )?
    ;

/*x rev 1 */
actualParametersBlock
    : actualDataParameters
    | actualInstanceParameters
    | actualMessageParameters
    | actualTimerParameters
    ;

/*x <end> removed, D3 E */
actualInstanceParameters
	: INST! actualInstanceParmList
		{ ## = #( #[InstanceParameters], ## ) ;
		}
	;

/*x rev 1 */
actualInstanceParmList
	: actualInstanceParameter ( ","! actualInstanceParmList )? ;

/*x rev 1 */
actualInstanceParameter
	: instanceName ;

/*x <end> removed, D3 E */
actualMessageParameters
	: MSG! actualMessageList
		{ ## = #( #[MessageParameters], ## ) ; }
	;

actualMessageList
	: messageName ( (";" messageName) => ";"! actualMessageList )? ;

/*x <end> removed, D3 E */
actualTimerParameters
	: TIMER! actualTimerList
		{ ## = #( #[TimerParameters], ## ) ; }
	;

actualTimerList
	: timerName ( ("," timerName) => ","! actualTimerList )?  ;

parent : "#" ; // Helmut: Check AST for this!!!


/*  the end token must obviously be at the end
	   of a referenceGateInterface ... */ // Helmut: Check this!
/*x Put end token at the end instead of front */
referenceGateInterface
	: ( GATE! refGate end )*
    ;

refGate
	: ( ( gateName )? OUT ) => actualOutGate
	| ( ( gateName )? IN ) => actualInGate
	| actualOrderOutGate
	| ( gateName ( AFTER orderDest )? end ) => actualOrderInGate
	| actualCreateOutGate
	| actualCreateInGate
	| ( ( gateName )? CALL ) => actualOutCallGate
	| ( ( gateName )? RECEIVE ) => actualInCallGate
	| ( ( gateName )? REPLYOUT ) => actualOutReplyGate
	| actualInReplyGate
	;

/* [Z.120] 1.9.4	-- Instance decomposition */

decomposition
	: DECOMPOSED! ( substructureReference )?
		{ ## = #( #[Decomposition], ## ) ; }
	;

substructureReference
	: AS! messageSequenceChartName ; // Helmut: Check AST for this!

/* [Z.120] 1.9.5	-- High-level MSC (HMSC) */

hmsc	: EXPR! mscExpression
		{ ## = #( #[HmscBody], ## ) ; }
	;

mscExpression
	: start ( nodeExpression | textDefinition )* 
	{ ## = #( #[MscExpression], ## ) ; }

	;

start	: labelNameList end ;

/*x rev 1 */
/*x moved SEQ! "("! labelNameList ")"! into nodeExprBody, TD33 */
nodeExpression
	: labelName ":"! ( ( ( timeableNode | node ) SEQ! "("! labelNameList ")"! ) 
                       | END ) 
      end
		{ ## = #( #[NodeExpression], ## ) ; }
    ;

labelNameList
	: labelName ( ALT! labelName )*
		{ ## = #( #[LabelNameList], ## ) ; }
	;

/*x rev 1 */
/*x Note: D3 F suggests to replace most of the <end>s by ";"*/
timeableNode 
        : (
            ( "("! mscRefExpr ")"!
	        | parExpression )
		time:(! TIME ti:timeInterval e1:end {#time = #([Time], ti, e1); } )?
		top:(! TOP ttdl:timeDestList e2:end {#top = #([Top], ttdl, e2); } )?
		bottom:(! BOTTOM btdl:timeDestList e3:end {#bottom = #([Bottom], btdl, e3); } )?
         )
	  { ## = #( #[TimeableNode], ##, time, top, bottom ) ; }
        ;

/*x rev 1 */
node	
        : ( ( { msc96==true }? ( EMPTY | mscName ) ) /*x only used in msc96 */
          | conditionIdentification
          | CONNECT 
          )
		{ ## = #( #[Node], ## ) ; }
	;

parExpression 
	: EXPR! mscExpression ENDEXPR!
		( PAR! EXPR! mscExpression ENDEXPR! )*
          { ## = #( #[ParExpression], ## ) ; }
	;

/* Names : */

mscName
	: Name { ##->setType(MscName); } ;

instanceName
	: Name { ##->setType(InstanceName); } ;

/*x removed rev. 1 */
/*
instanceParameterName
	: Name { ##->setType(InstanceParameterName); } ;
*/

/*x Added, D3 E */
actualInstanceParameterName
	: Name { ##->setType(ActualInstanceParameterName); } ;

eventName
	: Name { ##->setType(EventName); } ;

messageName
	: Name { ##->setType(MessageName); } ;

messageInstanceName
	: Name { ##->setType(InstanceName); } ;

gateName
	: Name ;

conditionName
	: ( Name | CharacterString ) { ##->setType(ConditionName); } ;
/*XXX Helmut: probably a Data string is meant! */

/*x for MSC96 backward compat. */
durationName
	: Name { ##->setType(DurationName); } ;

timerName
	: Name { ##->setType(TimerName); } ;

timerInstanceName
	: Name { ##->setType(InstanceName); } ;

intervalName
	: Name  { ##->setType(IntervalName); };

inlineExprName
	: Name  { ##->setType(InlineExprName); };

mscReferenceName
	: Name { ##->setType(ReferenceName); } ;

messageSequenceChartName
	: Name { ##->setType(MessageSequenceChartName); } ;

labelName
	: Name { ##->setType(LabelName); } ;

dataLanguageName
	: Name { ##->setType(DataLanguageName); } ;

/*x added, since rev. 1 doesn't provide a type for kindDenominator, Helmut */
kindName
	: Name { ##->setType(KindName); } ;

/* Identifiers : */

sdlDocumentIdentifier
	: identifier ;

variableIdentifier
	: identifier ;

/* Expressions : */

timeExpression
	: expression ;

/* Patterns : */

timePattern
	: pattern ;

/* Durationlimits : */

minDurationlimit
	: durationlimit ;

maxDurationlimit
	: durationlimit ;

/* Strings : */

/* The Z.120 <_expression_ string> non-terminals
   are named expressionString */

/*x deviation concerning data strings from the standard */
expressionString
	: (CharacterString | Name)
		{ ##->setType(ExpressionString); }
	;

typeRefString
	: (CharacterString | Name)
		{ ##->setType(TypeRefString); }
    ;

variableString
	: (CharacterString | Name)
		{ ##->setType(VariableString); }
    ;

dataDefinitionString
	: (CharacterString | Name)
		{ ##->setType(DataDefinitionString); }
    ;

wildcardString
	: (CharacterString | Name)
		{ ##->setType(WildcardString); }
    ;

/* CreateGateIdentification : */

createGateIdentification
	: msgIdentification ;

